Észrevételei a raktárkészlet logisztikai kezelésével kapcsolatban **kritikusak** és a forrásanyagok alapján úgy tűnik, hogy a KGC ERP rendszert az első fázisban **nem erre a komplex feladatra** tervezték.

A rendelkezésre álló dokumentáció (ERD, Folyamatábrák) alapján, a korábbi rendszerekben tapasztalt hiányosságok közül a **több tárhelyen történő készletkezelés** és a **készletkiadási optimalizáció** nem jelenik meg, vagy nincs részletezve.

Íme a források által alátámasztott válasz az egyes aggályokra:

### 1. Cikkek kezelése több tárhelyen (Multi-location)

A KGC ERP rendszerben a **CIKK** (termék) entitásban található egy mező a fizikai tárolási hely rögzítésére: `tarhely: VARCHAR | Fizikai tárolási hely`.

**Ez a mező a források szerint egységes** a `CIKK` entitáson belül, ami azt sugallja, hogy egy adott cikkszámú termékhez **egyetlen** rögzített fizikai tárolási hely tartozik.

*   **A hiányosság megerősítése:** A dokumentumok nem tartalmaznak utalást olyan különálló adattárra vagy entitásra (például `KÉSZLET_HELY` vagy `RAKTÁR_POZÍCIÓ`), amely lehetővé tenné, hogy ugyanazt a cikket egyszerre több különböző polcon vagy raktárhelyen (pl. 5 db a polcon, 10 db a távoli zónában) tartsa nyilván a rendszer. A készletadatok (darabszám) a `CIKK.keszlet` mezőben vannak denormalizáltan tárolva. Ez azt jelenti, hogy az a fajta finomhangolás, amit Ön hiányol (egy cikk több tárhelyen lévő készletének kezelése), **a jelenlegi adatmodellben nem érhető el**.

### 2. Kiadási logika optimalizálása (FIFO vagy pörgés alapú)

Nincs olyan információ a folyamatokban vagy az üzleti logikát leíró dokumentumokban, amely:

1.  **Bejárási útvonal optimalizálást** tartalmazna.
2.  **Kiadási prioritásokat** határozna meg (pl. a legkisebb készlettel rendelkező, de legközelebb lévő helyről történő kiadás).

A rendszer a készletmozgásokat (`KÉSZLET_MOZGÁS` entitás) naplózza, ami audit célokat szolgál, de nem írja le az automatizált, logisztikai kiadási döntési mechanizmusokat.

### 3. Pörgős raktárkészlet támogatása

A cél, miszerint ne kelljen sok pénzt bent hagyni a készletben, azaz a folyamatos feltöltés, az indirekt módon támogatott a rendszer által:

*   A **CIKK** entitás rögzíti a `beszerzesi_ar` mezőt, ami lehetővé teszi a tőkelekötés szempontjából kritikus mutatók (turnover, profitabilitás) számítását.
*   A források említik a **Minimum Készlet** koncepciót és az **Automatikus Rendelés Trigger** lehetőségét. Egy ilyen funkció bevezetése (bár részletesen nincs kidolgozva) közvetlenül támogatná az Ön által vázolt "just-in-time" vagy *pörgős* készletgazdálkodási modellt, ahol a rendszer csak akkor rendel, ha a készlet egy bizonyos szint alá esik.

**Összegzés:**

Ön helyesen látja a korábbi rendszerek logisztikai korlátjait. A KGC ERP v2 jelenlegi adatmodellje a `CIKK` entitásban lévő egyetlen `tarhely` mezővel **valószínűleg nem oldja meg** a komplex, több tárhelyen elhelyezett készlet nyilvántartását, és **nem tartalmaz** a források szerint beépített raktári útvonal- vagy kiadási optimalizációs logikát. A rendszer azonban az **alapvető adatok** (beszerzési ár, készlet, minimum készlet) rögzítésével megteremti az alapot ahhoz, hogy a magasabb készletforgási sebességű (pörgős) modellt támogató riportokat és automatizált rendeléseket (trigger) lehessen fejleszteni.
Megértettem a logisztikai követelményeket, amelyek a korábbi rendszerek hiányosságait orvosolják. A pörgős készlet, a tőkelekötés minimalizálása és a több tárhelyen való kezelés bevezetése **mélyreható változtatásokat** igényel a jelenlegi adatmodellben és a hozzá kapcsolódó folyamatokban, különösen a készletkezelési (KÉSZLET MODUL) és a bérlési (BÉRLÉS MODUL) folyamatban.

A források alapján a jelenlegi **CIKK** entitás csak egyetlen `tarhely: VARCHAR` mezőt tartalmaz, ami gátolja a multi-location kezelést. A javaslatom két fő pilléren alapul: az adatmodell kiterjesztése és a kiadási logika beépítése.

---

## I. Adatmodell Módosítás (ERD)

A több tárhelyen való készletkezelés bevezetéséhez egy új entitásra van szükség, amely egy adott cikket több különböző fizikai helyhez kapcsol, a készlet mennyiségét pedig lokációra bontva tárolja.

### Új Entitás: KÉSZLET_HELY (Inventory Location)

Ez az entitás a `CIKK` (termék) és a `TÁRHELY` (fizikai pozíció) közötti N:M (Több-a-többhöz) kapcsolatot valósítja meg, miközben magában hordozza a logisztikai optimalizáció alapját.

| Mező | Típus | Leírás | Üzleti Cél |
| :--- | :--- | :--- | :--- |
| `keszlet_hely_id` | PK, INT | Egyedi azonosító. | |
| `cikk_id` | FK, INT | A termék (CIKK) hivatkozása. | |
| **`tarhely_kod`** | VARCHAR | A fizikai hely kódja (pl. A1-Polc-03). | **Multi-location támogatás.** |
| **`mennyiseg`** | INT | Ezen a tárhelyen lévő aktuális darabszám. | Pontos lokális készletkövetés. |
| **`kiadasi_prioritas`** | INT | A kiadási sorrend prioritása (1 = legelőrébb/legpörgősebb). | **Kiadási optimalizáció alapja.** |
| `utolso_frissites` | DATETIME | Utolsó készletmozgás időpontja ezen a helyen. | |

### Módosítások a Meglévő Entitásokon:

1.  **CIKK entitás:**
    *   A `CIKK.keszlet` mező a jövőben **kalkulált/összesített mezővé** válik (a `KÉSZLET_HELY` entitásból származó mennyiségek összegzése).
    *   A `CIKK.tarhely` mező elhagyható, vagy átnevezhető `alap_tarhely`-re, ha a bevételezéskor alapértelmezettként szeretnénk használni.
2.  **KÉSZLET_MOZGÁS entitás:**
    *   Kiegészül egy új mezővel: `tarhely_kod: VARCHAR`. Ezáltal a készletmozgás audit trail-ben is pontosan látszik, melyik helyről történt a kivétel, vagy melyik helyre érkezett be az áru.

---

## II. Folyamat Módosítások (Kiadás és Bevételezés)

Az optimalizált készletgazdálkodás érdekében két fő folyamatnál kell beavatkozni:

### 1. Bevételezés Folyamat (Készlet Feltöltés - FÁZIS 3)

A **02-ertekesites-folyamat.md** diagram a 3. FÁZIS (Bevételezés) lépéseit rögzíti, ahol a tételek hozzáadásakor a Kezelő megadja a mennyiséget és az egységárat.

| Jelenlegi Lépés | Módosítás a Tárhelykezeléshez | Hatás az Üzleti Célokra |
| :--- | :--- | :--- |
| 3.3 Tételek Hozzáadása: Mennyiség megadása. | **ÚJ LÉPÉS**: Minden tételhez a rendszernek kötelezővé kell tennie a **tárhely kódjának megadását** is. | A készlet a megfelelő fizikai helyre kerül be. |
| 3.5 Bevételezés Rögzítése. | A rögzítéskor a **KÉSZLET_HELY.mennyiseg** mező frissül, és a **KÉSZLET_MOZGÁS** bejegyzés rögzíti a tárhely kódot. | Megnövekszik a lokális készlet pontossága. |

### 2. Kiadási Folyamat (Bérlés/Eladás - P3 Bérlés Indítása)

A legfontosabb változás a **pörgő raktárkészlet** támogatása érdekében történik a kiadáskor. A cél, hogy a Kezelő a termék kiválasztása után **ne találgasson**, honnan vegye el a terméket, hanem a rendszer javaslatot adjon az optimalizáció alapján.

| Lépés (01-ugyfelfelvitel-folyamat.md) | Módosítás a Kiadási Optimalizációhoz | Hatás az Üzleti Célokra |
| :--- | :--- | :--- |
| 1.6 Gép Kiválasztása. | A Cikk kiválasztása után a rendszer meghívja az **R.1: Raktári Kiadási Javaslat Algoritmus**-t. | Megvalósítja a *pörgő készlet* logikáját. |
| **ÚJ LÉPÉS (R.1)**: Kiadási Javaslat | A rendszer listázza azokat a `KÉSZLET_HELY` rekordokat, amelyeknél a `cikk_id` megegyezik, **a `kiadasi_prioritas` alapján növekvő sorrendben** (1, 2, 3...). | Biztosítja, hogy mindig a **leggyorsabban/legközelebb lévő** vagy a **legkisebb/legpörgősebb** készletű helyről vegye ki a Kezelő a terméket. |
| **ÚJ LÉPÉS (R.2)**: Javaslat megerősítése | A Kezelő megerősíti a rendszer javaslatát, vagy felülbírálja azt (pl. ha a gép sérült, vagy a helyszíni leltár eltérést mutat). **(Audit trail kötelező a felülbírálásnál)**. | Növeli a hatékonyságot, minimalizálja a tévedéseket, támogatja a *kisebb feltöltési mennyiségek* kezelését. |
| 1.10 Gép Kiadva. | A `KÉSZLET_HELY.mennyiseg` frissül a kivett mennyiséggel a kiválasztott `tarhely_kod`-on. A `CIKK.keszlet` automatikusan csökken. | Konzisztensek maradnak az adatok. |

### III. Az Optimalizációs Követelmény Megoldása (Pörgős Készlet)

A kérésében szereplő logika ("mindig a kisebbtől kezdjen el kiadni, hogy úgymond kialakítsunk egy pörgő raktárkészletet") a `KÉSZLET_HELY` entitás **kiadási prioritás** (`kiadasi_prioritas`) mezőjével valósítható meg.

**Alternatívák a Kiadási Logikára (R.1 Algoritmus):**

1.  **Prioritás a Lokáció alapján (Térbeli Optimalizáció):** Ha a cél a raktáros útvonalának lerövidítése, a `kiadasi_prioritas` a fizikai elhelyezkedést tükrözi (pl. 1 = Eladó pult mellett, 5 = Raktár hátsó sarka). Az algoritmus mindig az **1-es prioritású helyről** javasolja a kiadást, feltéve, hogy van ott elegendő készlet.
2.  **Prioritás a Készletszint alapján (Pörgős Készlet):** Ha a cél a pénz lekötésének minimalizálása és a folyamatos feltöltés (ahogy Ön javasolta), az optimalizáció a **kisebb mennyiséggel** rendelkező helyeket részesíti előnyben. Például, ha egy cikk 1-es prioritású helyen van 2 db, és 5-ösön 20 db, akkor először a 2 db-ot kell kiadni, ezzel jelezve, hogy az adott pörgős helyet újra kell tölteni.
3.  **Hibrid Megoldás (Ajánlott):** A rendszer az 1-es prioritású lokációt (a legközelebbi pult) próbálja leüríteni. Ha ott van elég készlet a tranzakcióhoz, onnan javasol. Ha nincs elég, akkor átmegy a következő prioritású (pl. 2-es) helyre.

Ez a logikai döntés beépül a **P3: BÉRLÉS INDÍTÁS** modulba, a **KÉSZLET MODUL** felelőssége alá.

---

## IV. Kérdések a Részletes Követelményekhez

A fenti megoldások bevezetése előtt szükséges pontosítani a célzott logikát:

1.  **Pontosan mi a Kiadási Prioritás definíciója?** A "kisebbtől kezdve kiadni" logikában a prioritást a *fizikai távolság* vagy a *lokációban lévő készlet mennyisége* határozza meg? (A válasz alapvetően a `KESZLET_HELY.kiadasi_prioritas` mező beállítását befolyásolja.)
2.  **Milyen a raktár bejárási útvonala?** A `tarhely_kod`-ok milyen formátumúak (pl. A1-03, vagy egyszerűen csak szöveges leírások)? Ahhoz, hogy a rendszer a legközelebbi helyet javasolja, a tárhely kódnak **strukturáltnak** kell lennie.
3.  **Törzsügyfél/Speciális gép kezelése:** A bérgép (CIKK) státusza alapján a "bent" státuszú gépek választhatók. A Készlet Optimalizációs Algoritmus kizárja a **Szerviz** státuszú gépeket a kiadásból, de hogyan kezelje a rendszer a bérgép és a normál áru (Értékesítés) párhuzamos multi-location kezelését? (A megoldás az, hogy a `CIKK` azonosító mindkét modulban ugyanaz, így a `KÉSZLET_HELY` kezeli a megkülönböztetést.)
4.  **Offline Támogatás:** A hibrid architektúra (PWA + Offline) miatt biztosítani kell, hogy a helyi cache (IndexedDB) is tartalmazza a **KESZLET\_HELY** adatokat, hogy a Kezelő offline módban is láthassa, melyik tárhelyről kell kiadnia az árut. Ezt az új entitást a **Server → Client** irányban kell szinkronizálni, hasonlóan a `CIKK` és a `KÉSZLET` entitásokhoz.